\section{Basic Principles of Quantum Computing}

\subsection{Information Representation. Classical and Quantum States}
The main difference between quantum and classical computers lies in how they store information.

In the classical case, information is stored in certain memory cells. The state of each memory cell is described by a single number that can take the value 0 or 1. If $m$ memory cells are combined, the overall state of the classical system (which it can assume at a specific moment in time) is described by $m$ numbers.

In the quantum case, a memory cell is represented by a qubit, which requires two complex numbers $\alpha_0$ and $\alpha_1$ to describe it \footnote{More accurately, three real numbers are required because $\alpha_{0,1}$ are subject to the constraint $\left|\alpha_0\right|^2 + \left|\alpha_1\right|^2 = 1$, from which, considering $\alpha_{0,1} = r_{0,1}e^{i \theta_{0,1}}$, we obtain $r_0^2 = 1 - r_1^2$}:
\[
\left|\psi\right>_1 = \alpha_0 \ket{ 0 } + \alpha_1 \ket{ 1 }.
\]
To describe a composite system consisting of $m$ qubits, $2^m$ complex numbers are needed. Alternatively, one could say that a quantum state contains all possible classical states as a superposition. For example, consider a system consisting of 3 qubits:
\begin{eqnarray}
\left|\psi\right>_3 = 
\alpha_0 \ket{ 000 } + 
\alpha_1 \ket{ 001 } + 
\alpha_2 \ket{ 010 } + 
\alpha_3 \ket{ 011 } + 
\nonumber \\
+ 
\alpha_4 \ket{ 100 } + 
\alpha_5 \ket{ 101 } + 
\alpha_6 \ket{ 110 } + 
\alpha_7 \ket{ 111 }.
\label{eqQuantCompPrinciplePsi8}
\end{eqnarray}
As can be seen, any classical state of a 3-bit system is represented as one of the terms in the superposition \eqref{eqQuantCompPrinciplePsi8}. For example, the number $5_{10}=101_2$ is included in \eqref{eqQuantCompPrinciplePsi8} with the coefficient $\alpha_5$.

\subsection{Reversible Computations}

\input ./part4/quantcomp/figclasscomp.tex

In the classical case, computation involves transforming the initial $n$ bits into a result described by $m$ bits (see \autoref{figQuantCompClassComp}). This transformation is defined by some function $f\left(x\right)$. A typical example is addition modulo 2 (see Table \ref{tblXOR}), where the input is 2 bits ($n = 2$), and the output is 1 bit ($m = 1$).

\input ./part4/quantcomp/figquantcomp.tex

Such a scheme will not work in the quantum case primarily because the change of pure quantum states over time must occur via a unitary evolution operator \eqref{eqAddDiracEvolutionOper}, i.e., it must be reversible, which is impossible for our classical example \footnote{it is impossible to obtain two bits of initial information from one bit (the result)}. Therefore, quantum computations use a different scheme (see \autoref{figQuantCompQuantComp}) where reversible computations are possible.

At the input, together with the initial data $x$ described by $n$ qubits, $m$ qubits in the state $\ket{0}$ are provided, so that the total number of inputs and outputs corresponds to each other. Consequently, the relationship between input and output can be described in the form
\footnote{More accurately written in a general form as 
$
\underbrace{\ket{x}}_n
\underbrace{\left|f\left(x\right)\right>}_m
\underbrace{\ket{r}}_k = 
\hat{U}_f \underbrace{\ket{x}}_n
\underbrace{\left|0 \dots 0\right>}_{m+k},
$
where $\ket{r}$ is a remainder of size $k$ qubits that is not used in the calculations and serves the purpose of ensuring the unitarity of the operator $\hat{U}_f$
}
\begin{equation}
\underbrace{\ket{x}}_n
\underbrace{\left|f\left(x\right)\right>}_m = 
\hat{U}_f \underbrace{\ket{x}}_n\underbrace{\left|0 \dots 0\right>}_m.
\label{eqQuantCompQuantComp}
\end{equation}