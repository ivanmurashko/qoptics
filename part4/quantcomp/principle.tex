%% -*- coding:utf-8 -*- 
\section{Basic Principles of Quantum Computing}

\subsection{Information Representation. Classical and Quantum States}
The main difference between quantum and classical computers lies in how they store information.

In the classical case, information is stored in certain memory cells. The state of each memory cell is described by a single number that can take the value 0 or 1. If $m$ memory cells are combined, then the overall state of the classical system (which it can assume at any given moment) is described by $m$ numbers.

In the quantum case, a memory cell is represented by a qubit, which requires two complex numbers $\alpha_0$ and $\alpha_1$ for its description \footnote{More correctly, it is described by three real numbers because the following constraint applies to $\alpha_{0,1}$: $\left|\alpha_0\right|^2 + \left|\alpha_1\right|^2 = 1$, from which, considering $\alpha_{0,1} = r_{0,1}e^{i \theta_{0,1}}$, we obtain that $r_0^2 = 1 - r_1^2$}:
\[
\left|\psi\right>_1 = \alpha_0 \ket{ 0 } + \alpha_1 \ket{ 1 }.
\]
To describe a composite system consisting of $m$ qubits, $2^m$ complex numbers are necessary. In other words, a quantum state contains all possible classical states as a superposition. As an example, one can consider a system consisting of 3 qubits:
\begin{eqnarray}
\left|\psi\right>_3 = 
\alpha_0 \ket{ 000 } + 
\alpha_1 \ket{ 001 } + 
\alpha_2 \ket{ 010 } + 
\alpha_3 \ket{ 011 } + 
\nonumber \\
+ 
\alpha_4 \ket{ 100 } + 
\alpha_5 \ket{ 101 } + 
\alpha_6 \ket{ 110 } + 
\alpha_7 \ket{ 111 }.
\label{eqQuantCompPrinciplePsi8}
\end{eqnarray}
As can be seen, any classical state of a 3-bit system is represented as one of the terms in the superposition \eqref{eqQuantCompPrinciplePsi8}. For example, the number $5_{10}=101_2$ is included in \eqref{eqQuantCompPrinciplePsi8} with the coefficient $\alpha_5$.

\subsection{Reversible Computation}

\input ./part4/quantcomp/figclasscomp.tex

In the classical case, computation consists of transforming the initial $n$ bits into a result described by $m$ bits (see \autoref{figQuantCompClassComp}). This transformation is defined by some function $f\left(x\right)$. A typical example is addition modulo 2 (see table \ref{tblXOR}), where 2 bits are input ($n = 2$), and 1 bit is the output ($m = 1$).

\input ./part4/quantcomp/figquantcomp.tex

Such a scheme will not work in the quantum case primarily because the change in pure quantum states over time must be accomplished via a unitary evolution operator \eqref{eqAddDiracEvolutionOper}, i.e., it must be reversible, which is impossible for our classical example \footnote{It is impossible to obtain two bits of original information from one bit (the result)}. Therefore, a different scheme is used in quantum computing (see \autoref{figQuantCompQuantComp}) where reversible computations are possible.

The input, along with the initial data $x$ described by $n$ qubits, includes $m$ qubits in the state $\ket{0}$, ensuring that the total number of inputs and outputs match each other. Consequently, the relationship between input and output can be described in the form
\footnote{More correctly written in general form as 
$
\underbrace{\ket{x}}_n
\underbrace{\left|f\left(x\right)\right>}_m
\underbrace{\ket{r}}_k = 
\hat{U}_f \underbrace{\ket{x}}_n
\underbrace{\left|0 \dots 0\right>}_{m+k},
$
where $\ket{r}$ is a remainder of size $k$ qubits not used in the calculations and serves the purpose of ensuring the unitarity of the operator $\hat{U}_f$
}
\begin{equation}
\underbrace{\ket{x}}_n
\underbrace{\left|f\left(x\right)\right>}_m = 
\hat{U}_f \underbrace{\ket{x}}_n\underbrace{\left|0 \dots
  0\right>}_m.
\label{eqQuantCompQuantComp}
\end{equation}